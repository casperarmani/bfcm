Let's create a detailed, step-by-step implementation plan that maintains our existing functionality while adding robust session management.

Step 1: Create Session Configuration
First, create a new file session_config.py:

from datetime import timedelta
class SessionConfig:
    SLIDING_WINDOW = 3600  # 1 hour sliding window
    ABSOLUTE_MAX = 86400   # 24 hour maximum session lifetime
    GRACE_PERIOD = 300     # 5 minute grace period for renewal
    CLEANUP_INTERVAL = 600 # 10 minute cleanup interval
    
    # Cookie settings
    COOKIE_NAME = "session_id"
    COOKIE_SECURE = True
    COOKIE_HTTPONLY = True
    COOKIE_SAMESITE = "lax"
Step 2: Update RedisManager Class

from session_config import SessionConfig
import time
import json
class RedisManager:
    # Add these methods to existing RedisManager class
    
    async def set_session(self, session_id: str, session_data: dict) -> bool:
        try:
            key = self._build_key(self.session_prefix, session_id)
            session_data['created_at'] = time.time()
            session_data['last_refresh'] = time.time()
            
            return bool(self.redis.set(
                key,
                json.dumps(session_data),
                ex=SessionConfig.SLIDING_WINDOW
            ))
        except Exception as e:
            logger.error(f"Error setting session: {str(e)}")
            return False
    async def extend_session(self, session_id: str) -> bool:
        try:
            key = self._build_key(self.session_prefix, session_id)
            session_data = self.get_session(session_id)
            
            if not session_data:
                return False
                
            created_at = session_data.get('created_at', time.time())
            if time.time() - created_at > SessionConfig.ABSOLUTE_MAX:
                await self.delete_session(session_id)
                return False
                
            session_data['last_refresh'] = time.time()
            return bool(self.redis.set(
                key,
                json.dumps(session_data),
                ex=SessionConfig.SLIDING_WINDOW
            ))
        except Exception as e:
            logger.error(f"Error extending session: {str(e)}")
            return False
    async def cleanup_expired_sessions(self):
        try:
            pattern = f"{self.session_prefix}*"
            cursor = 0
            while True:
                cursor, keys = self.redis.scan(cursor, match=pattern)
                current_time = time.time()
                
                for key in keys:
                    try:
                        session_data = json.loads(self.redis.get(key))
                        if not session_data:
                            continue
                            
                        created_at = session_data.get('created_at')
                        last_refresh = session_data.get('last_refresh')
                        
                        if (current_time - created_at > SessionConfig.ABSOLUTE_MAX or
                            current_time - last_refresh > SessionConfig.SLIDING_WINDOW):
                            self.redis.delete(key)
                            
                    except Exception as e:
                        logger.error(f"Error processing session key {key}: {str(e)}")
                        
                if cursor == 0:
                    break
                    
        except Exception as e:
            logger.error(f"Error in session cleanup: {str(e)}")
Step 3: Update app.py endpoints:

from session_config import SessionConfig
# Update existing login_post endpoint
@app.post('/login')
async def login_post(
    request: Request,
    email: str = Form(...),
    password: str = Form(...),
    response: Response = None
):
    try:
        if not redis_manager.check_rate_limit("login", request.client.host):
            raise HTTPException(
                status_code=429,
                detail="Too many login attempts. Please try again later."
            )
        auth_response = supabase.auth.sign_in_with_password({
            "email": email,
            "password": password
        })
        if not auth_response.user:
            logger.error("Login failed: No user in response")
            return JSONResponse(
                status_code=400,
                content={"success": False, "message": "Invalid credentials"}
            )
        user = await get_user_by_email(email)
        if not user:
            user = await create_user(email)
        session_id = secrets.token_urlsafe(32)
        session_data = {
            "id": str(user.get("id")),
            "email": email,
            "created_at": time.time(),
            "last_refresh": time.time()
        }
        if not await redis_manager.set_session(session_id, session_data):
            raise HTTPException(
                status_code=500,
                detail="Failed to create session"
            )
        response = JSONResponse(content={"success": True, "message": "Login successful"})
        response.set_cookie(
            key=SessionConfig.COOKIE_NAME,
            value=session_id,
            httponly=SessionConfig.COOKIE_HTTPONLY,
            secure=SessionConfig.COOKIE_SECURE,
            samesite=SessionConfig.COOKIE_SAMESITE,
            max_age=SessionConfig.SLIDING_WINDOW
        )
        return response
    except Exception as e:
        logger.error(f"Login error: {str(e)}")
        return JSONResponse(
            status_code=400,
            content={"success": False, "message": str(e)}
        )
# Update auth_status endpoint
@app.get('/auth_status')
async def auth_status(request: Request, response: Response):
    try:
        session_id = request.cookies.get(SessionConfig.COOKIE_NAME)
        if not session_id:
            return JSONResponse(
                status_code=status.HTTP_200_OK,
                content={
                    "authenticated": False,
                    "message": "No session found"
                }
            )
        if await redis_manager.extend_session(session_id):
            user = await get_current_user(request, return_none=True)
            
            response.set_cookie(
                key=SessionConfig.COOKIE_NAME,
                value=session_id,
                httponly=SessionConfig.COOKIE_HTTPONLY,
                secure=SessionConfig.COOKIE_SECURE,
                samesite=SessionConfig.COOKIE_SAMESITE,
                max_age=SessionConfig.SLIDING_WINDOW
            )
            
            return JSONResponse(
                status_code=status.HTTP_200_OK,
                content={
                    "authenticated": user is not None,
                    "user": user if user else None,
                    "session_status": "active",
                    "expires_in": SessionConfig.SLIDING_WINDOW
                }
            )
        else:
            response.delete_cookie(key=SessionConfig.COOKIE_NAME)
            return JSONResponse(
                status_code=status.HTTP_200_OK,
                content={
                    "authenticated": False,
                    "message": "Session expired or invalid"
                }
            )
    except Exception as e:
        logger.error(f"Auth status error: {str(e)}")
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={
                "authenticated": False,
                "error": str(e),
                "session_status": "error"
            }
        )
# Add startup event
@app.on_event("startup")
async def startup_event():
    app.state.start_time = time.time()
    app.state.request_count = 0
    
    async def cleanup_sessions():
        while True:
            await redis_manager.cleanup_expired_sessions()
            await asyncio.sleep(SessionConfig.CLEANUP_INTERVAL)
    
    asyncio.create_task(cleanup_sessions())
Step 4: Update frontend session management in templates/index.html:

// Add this to your existing JavaScript
async function manageSession() {
    const KEEPALIVE_INTERVAL = 240000; // 4 minutes
    const WARNING_THRESHOLD = 300000;   // 5 minutes before expiry
    
    let sessionTimer;
    let warningShown = false;
    
    async function checkSession() {
        try {
            const response = await fetch('/auth_status', {
                credentials: 'include'
            });
            const data = await response.json();
            
            if (data.authenticated) {
                warningShown = false;
                
                if (data.expires_in < WARNING_THRESHOLD && !warningShown) {
                    warningShown = true;
                    // You can implement a UI warning here
                    console.warn(`Session expires in ${Math.floor(data.expires_in/60000)} minutes`);
                }
            } else {
                window.location.href = '/login';
            }
        } catch (error) {
            console.error('Session check error:', error);
        }
    }
    
    // Start session management
    sessionTimer = setInterval(checkSession, KEEPALIVE_INTERVAL);
    
    // Initial check
    await checkSession();
    
    // Cleanup on page unload
    window.addEventListener('unload', () => {
        if (sessionTimer) clearInterval(sessionTimer);
    });
}
// Start session management when page loads
document.addEventListener('DOMContentLoaded', manageSession);
This implementation:

✅ Maintains all existing functionality
✅ Adds secure session management
✅ Implements sliding window expiration
✅ Adds session cleanup
✅ Enhances security with proper cookie settings
✅ Provides frontend session management
The changes are backwards compatible and won't break existing functionality because:

We're extending existing Redis functionality, not replacing it
Session cookie names remain the same
Existing auth flows are preserved
Error handling is comprehensive
We maintain existing rate limiting
Would you like me to break down any part of the implementation in more detail?